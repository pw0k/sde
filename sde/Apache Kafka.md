распределенная потоковая платформа с открытым исходным кодом, разработанная для обработки потоков данных в реальном времени. Она используется для построения систем реального времени с высокой пропускной способностью, низкой задержкой и возможностью масштабирования.

### Ключевые концепции
- **Producer (Производитель)**: Приложение или сервис, который публикует сообщения в Kafka.
- **Consumer (Потребитель)**: Приложение или сервис, который читает сообщения из Kafka.
- **Topic (Топик)**: Категория или канал, куда публикуются сообщения. Топики являются логическими именами для потоков данных.
- **Partition (Партиция)**: Топик разбит на несколько партиций для параллелизма и масштабирования. Каждая партиция — это упорядоченный, неизменяемый список сообщений.
- **Offset (Смещение)**: Порядковый номер сообщения в партиции. Используется для отслеживания прогресса потребителя.
- **Broker (Брокер)**: Сервер Kafka, который принимает и сохраняет сообщения.
- **Cluster (Кластер)**: Набор брокеров, работающих совместно для обеспечения высокой доступности и отказоустойчивости.
- **Zookeeper**: Служба координации, используемая Kafka для хранения метаданных кластера (в версиях до Kafka 2.8). С более новых версий Kafka может работать без Zookeeper, используя внутренний координатор Kafka Raft (KRaft).
    

### Архитектура Kafka
- **Продюсеры** публикуют сообщения в определенные топики.
- **Брокеры** принимают сообщения и сохраняют их в соответствующие партиции топиков.
- **Потребители** подписываются на топики и читают сообщения, отслеживая смещения.
- **Кластеры** обеспечивают распределение нагрузки и отказоустойчивость через репликацию партиций.

### Основные компоненты

#### 1. **Producers (Производители)**

- **Отправка сообщений**: Производители отправляют данные в топики, выбирая партиции либо по ключу, либо по алгоритму round-robin.
    
- **Acknowledgments (Подтверждения)**: Контролируют уровень гарантии доставки:
    
    - **acks=0**: Производитель не ждет подтверждения.
    - **acks=1**: Ждет подтверждения от лидера партиции.
    - **acks=all**: Ждет подтверждения от всех реплик партиции.

#### 2. **Consumers (Потребители)**

- **Consumer Groups (Группы потребителей)**:
    
    - Потребители объединяются в группы для параллельного чтения.
    - Каждая партиция назначается одному потребителю в группе.
    - Позволяет масштабировать чтение данных из топиков.
- **Offset Management (Управление смещениями)**:
    
    - **Автоматическое смещение**: Смещения автоматически сохраняются в Kafka (по умолчанию).
    - **Ручное смещение**: Потребитель самостоятельно управляет смещениями.


### Доставка сообщений

- **At most once (Не более одного раза)**: Сообщения могут быть потеряны, но никогда не дублируются.
    
- **At least once (По крайней мере один раз)**: Сообщения не теряются, но могут быть доставлены более одного раза.
    
- **Exactly once (Ровно один раз)**: Сообщения не теряются и не дублируются. Требует дополнительной настройки и использования транзакций.

**Каждая партиция может быть назначена только одному потребителю** в группе, поэтому два потребителя одной группы не читают данные из одной и той же партиции одновременно.
Если в группе потребителей больше, чем партиций, некоторые потребители будут "простаивать" — Kafka просто не назначит им партиции. А если наоборот, партиций больше, чем потребителей, некоторые потребители будут обрабатывать несколько партиций.

### Kafka Streams и Kafka Connect
- **Kafka Streams**: Библиотека для создания приложений потоковой обработки данных непосредственно из топиков Kafka, без необходимости в дополнительных кластерах (например, Apache Spark или Flink).
- **Kafka Connect**: Фреймворк для подключения Kafka к внешним системам (базы данных, системы хранения, очереди) с помощью коннекторов.

### Популярные вопросы на собеседованиях
2. **Объясните архитектуру Kafka и роль основных компонентов.**
    - Kafka состоит из продюсеров, потребителей, брокеров, топиков и партиций. Продюсеры отправляют сообщения брокерам, которые сохраняют их в партициях топиков. Потребители читают сообщения из партиций, отслеживая смещения.
3. **Как Kafka обеспечивает отказоустойчивость и высокую доступность?**
    - Через репликацию партиций между брокерами. При сбое лидера партиции один из реплик становится новым лидером, обеспечивая непрерывность работы.
4. **Что такое партиции и зачем они нужны в Kafka?**
    - Партиции позволяют разделить топик на несколько частей для параллельной обработки и масштабирования. Они обеспечивают упорядоченность сообщений внутри себя.
5. **Как Kafka гарантирует порядок сообщений?**
    - Порядок сообщений гарантируется внутри одной партиции. Для сохранения порядка ключевые сообщения направляются в одну и ту же партицию.
6. **Что такое Consumer Group и как она работает?**
    - Группа потребителей, совместно потребляющих сообщения из топика. Каждая партиция назначается одному потребителю в группе, обеспечивая параллельную обработку и балансировку нагрузки.
7. **Объясните разницу между acks=0, acks=1 и acks=all у продюсера.**
    - **acks=0**: Продюсер не ждет подтверждения от брокера.
    - **acks=1**: Ждет подтверждения от лидера партиции.
    - **acks=all**: Ждет подтверждения от всех реплик партиции.
**Что такое Zookeeper и какую роль он играет в Kafka?**
- Zookeeper используется для хранения метаданных кластера Kafka, управления конфигурацией и координации брокеров. В новых версиях Kafka может работать без Zookeeper, используя KRaft.
**Как достичь exactly-once семантики в Kafka?**
- Используя транзакции Kafka и идемпотентных продюсеров, можно обеспечить ровно один раз доставку сообщений, избегая потерь и дубликатов.